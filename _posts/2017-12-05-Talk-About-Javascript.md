---
layout: blog
title: Talk About Javascript 
---
Javascript中有几个非常重要的语言特性——对象、原型继承、闭包。
其中闭包对于那些使用传统静态语言的程序员来说是一个新的语言特性。
闭包是Javascript语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。

## 闭包的定义

> A closure is the combination of a function and the lexical environment within which that function was declared.

> Closures(闭包)是使用被作用域封闭的变量，函数，闭包等执行的一个函数的作用域。通常我们用和其相应的函数来指代这些作用域。(可以访问独立数据的函数)

> 闭包是一个函数和声明该函数的词法环境的组合。从理论角度来说，所有函数都是闭包。

这是[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures)官方给出的闭包的定义。比较晦涩难懂。我个人理解为闭包有以下几个特点：
* 闭包就是能够读取其他函数内部变量的函数。
* 闭包就是函数的局部变量集合，只是这些局部变量在函数返回后会继续存在。
* 闭包就是就是函数的“堆栈”在函数返回后并不释放，我们也可以理解为这些函数堆栈并不在栈上分配而是在堆上分配
* 当在一个函数内定义另外一个函数就会产生闭包

由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成"定义在一个函数内部的函数"。

所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。

如果要全面学习学好Javascript高级技巧以及熟练运用框架和理解框架，那么一定要学好闭包。说到闭包，那就不得不说另外一个很让人感兴趣的话题，就是**变量的作用域**。

## 变量的作用域

我们可以回忆一下，我们现在在用的语言，拿C#来举例。你在一个方法中定义了一个变量，那么你只能在这个方法的范围内访问这个变量。在这个方法之外是无法访问到这个变量的。这就是变量的作用域。在Javascript中也是一样，我们考虑以下的Javascript代码片段：
```js
var a = 999;
function foo(){
    alert(a);
}
foo(); // 999
```

```js
function foo(){
    var a = 999;
}
alert(a); // error
```
Javascript函数内部可以访问全局变量，而函数外部则无法访问函数内部的变量。
那么我们有这样的场景，我需要从函数外部访问函数内部定义好的变量，应该怎么办？
这时候，闭包就派上用场了。

### 作用域是什么

要完全说清楚作用域，可能就要从Javascript引擎说起了。这里面包含了编译原理，以及引擎和作用域的交互。是个很复杂很大的话题。今天暂且不讨论这些。有兴趣的同学可以参见ECMAScript的[ECMA-262标准](https://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf)以及[Chrome V8 Engine](http://www.v8project.org)的具体实现。
下面我们通过一个简单的赋值语句来大体介绍一下引擎和作用域是如何协同工作的。

```js
var a = 2;
```

下面我们将这一句话分解开来看。其实这句话用我们熟悉的伪代码来表述就是：“为一个变量分配一份内存，并命名为a，然后将2这个值保存到a这个变量中”。那我们来看编译器是如何处理的：
1. 遇到 var a，编译器会询问作用域，是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译。否则，它会要求作用域在当前的作用域集合中声明一个新的变量，并命名为 a。
2. 然后编译器会为引擎生成运行时所需要的代码，这些代码会处理a = 2这个操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫做a的变量。如果是，引擎就会使用这个变量，如果不是，那么引擎会继续查找该变量。

明白了这个道理，我们再看上面两个例子，就明白为什么函数外部访问不了函数内部定义的变量了。

> 这里有个引申的学习点，在这里我只是大体的介绍了什么是作用域，如果想深入学习，可以了解一些有关词法作用域/函数作用域/块作用域。